
//=========================================================================
//	
//=========================================================================

#ifndef PM_STR_H
#define PM_STR_H
#undef GLOBAL
#ifdef PM_STR_H_GLOBAL
#define GLOBAL /*	*/
#else
#define GLOBAL extern
#endif

//=========================================================================
//	定義
//=========================================================================
//#define name value

#define STR_TEMP_BUF_LEN	20
#define	MSG_EXPAND_BUF_LEN	1000

typedef enum{
		NUM_MODE_LEFT,		/* 左詰 */
		NUM_MODE_SPACE,		/* 右詰、足りない部分は空白	*/
		NUM_MODE_ZERO,		/* 右詰、足りない部分は数字のゼロ */
}NUM_MODE_TYPE;

#include "i_msg.ndw"		//I_MSG_で参照するバッファのID定義
							//i_msg.tblからコンバートされる

//typedef ...


//=========================================================================
//	変数
//=========================================================================
//GLOBAL type valiable;

extern u8 StrTempBuffer0[STR_TEMP_BUF_LEN];
extern u8 StrTempBuffer1[STR_TEMP_BUF_LEN];
extern u8 StrTempBuffer2[STR_TEMP_BUF_LEN];
extern u8 MsgExpandBuffer[MSG_EXPAND_BUF_LEN];

//=========================================================================
//	関数プロトタイプ
//=========================================================================

//-------------------------------------------------------------------------
//	ポケモン名のバッファ間コピー
//	※国別バージョンによって最大文字数制限が違う
//	<引数>	to_str		コピー先バッファ
//			from_str	コピー元バッファ
//	<戻り値>
//			コピー先バッファのEOM_を書き込んだアドレス
//-------------------------------------------------------------------------
GLOBAL u8 * NickNameCopy( u8 * to_str, const u8 * from_str );

//-------------------------------------------------------------------------
//	ポケモン名の終端チェック処理
//	※日本版の場合、6文字以上ある場合はEOM_で削除する
//	<引数>	s		名前が入っているバッファ
//	<戻り値>		EOM_アドレス
//-------------------------------------------------------------------------
GLOBAL u8 * NickNameCutOff( u8 * s );

//-------------------------------------------------------------------------
//	親名のコピー
//	※国が違っても最大文字数制限は同じ
//	<引数>	to_str		コピー先バッファ
//			from_str	コピー元バッファ
//	<戻り値>
//			コピー先バッファのEOM_を書き込んだアドレス
//-------------------------------------------------------------------------
GLOBAL u8 * OyaNameCopy( u8 * to_str, const u8 * from_str );

//-------------------------------------------------------------------------
// PM_strcpy
// 文字列コピー
//
//	<入力パラメータ>
// 	to_str		コピー先バッファ
// 	from_str	文字列データ
//
// 	<返値>
// 	バッファにコピーしたデータ最後のEOM_へのポインタを返す
// 	データがない(文字列データ先頭がEOM_だった)場合、
// 	EOM_をバッファ先頭に書きこみ、そこへのポインタを返す
//-------------------------------------------------------------------------
GLOBAL u8 * PM_strcpy(u8 * to_str, const u8 * from_str);

//-------------------------------------------------------------------------
// PM_strcat
// 文字列連結
//
//	<入力パラメータ>
//	to_str		連結されるデータ（ram上にあること！！）
//	from_str	連結するデータ
//
// 	<返値>
//	連結後のバッファ上のデータ末のEOM_へのポインタを返す
//-------------------------------------------------------------------------
GLOBAL u8 * PM_strcat(u8 * to_str, const u8 * from_str);

//-------------------------------------------------------------------------
// PM_strncpy
// 文字列コピー		2002/05/15 by nakahiro
//
//	<入力パラメータ>
// 	to_str		コピー先バッファ
// 	from_str	文字列データ
//	len			コピーバイト数
//
// 	<返値>
//	「コピー先バッファ + コピーバイト数」へのポインタ
//-------------------------------------------------------------------------
GLOBAL u8 * PM_strncpy( u8 * to_str, const u8 * from_str, u8 len );

//-------------------------------------------------------------------------
// PM_strncat
// 文字列連結		2002/05/15 by nakahiro
//
//	<入力パラメータ>
//	to_str		連結されるデータ（ram上にあること！！）
//	from_str	連結するデータ
//	len			連結するバイト数
//
// 	<返値>
//	連結後のバッファ上のデータ末へのポインタを返す
//-------------------------------------------------------------------------
GLOBAL u8 * PM_strncat( u8 * to_str, const u8 * from_str, u8 len );

//-------------------------------------------------------------------------
// PM_strlen
// 文字列長取得
//
//	<入力パラメータ>
//	s		対象文字列へのポインタ
//
//	<返値>
//	対象文字列の長さ（EOM_までの文字数）を返す
//-------------------------------------------------------------------------
GLOBAL u16 PM_strlen(const u8 * s);

//-------------------------------------------------------------------------
//	文字列比較
//	※Ｃ標準関数と違い長さの比較はしていない
//
//	<入力パラメータ>
//	s,t		対象文字列へのポインタ
//
//	<返値>
//	一致した時０、それ以外の場合非０の値を返す
//	※Cの標準関数と違い長さの比較はしていない
//-------------------------------------------------------------------------
GLOBAL int PM_strcmp(const u8 *s, const u8 *t);

//-------------------------------------------------------------------------
//	文字列比較
//
//	<入力パラメータ>
//	s,t		対象文字列へのポインタ
//	n		比較する最大の文字数
//
//	<返値>
//	一致した時０、それ以外の場合非０の値を返す
//-------------------------------------------------------------------------
GLOBAL int PM_strncmp(const u8 *s, const u8 *t, int n );

//-------------------------------------------------------------------------
// PM_NumMsgSet
// 数値→文字列変換
//
//	<入力パラメータ>
//	buf		文字列を書きこむバッファのポインタ
//	num		文字列に変換したい数値
//	type	形式指定
//			== NUM_MODE_LEFT		 左詰
//			== NUM_MODE_SPACE		 右詰、足りない部分は空白
//			== NUM_MODE_ZERO		 右詰、足りない部分は数字のゼロ
//	keta	表示桁数
//
//	<返値>
//	数値の後ろに書きこんだEOM_へのポインタを返す
//-------------------------------------------------------------------------
GLOBAL u8 * PM_NumMsgSet(u8 * buf, int num, NUM_MODE_TYPE type, u8 keta);

//デバッグ用16進変換ルーチン
GLOBAL u8 * PM_HexNumMsgSet(u8 * buf, int num, NUM_MODE_TYPE type, u8 keta);

//=================================================================
// PM_MsgExpand
// メッセージ展開ルーチン
//
//	<入力パラメータ>
//	buf		メッセージを展開するバッファへのポインタ
//	data	展開する元データへのポインタ
//
//	<返値>
//	展開後のメッセージデータ末のEOM_へのポインタを返す
//=================================================================

GLOBAL u8 * PM_MsgExpand(u8 * buf, const u8 * data);

//=================================================================
//	点字データ展開ルーチン
//		※点字データにヘッダを付加、一文字ずつ間を空ける
//	<引数>	buf		展開先バッファ
//			data	読み込みデータ
//	<戻り値>		最後のEOM_を書き込んだバッファのアドレス
//=================================================================
GLOBAL u8 * PM_TenjiExpand( u8 * buf, const u8 * data );

/*======================================================================
==	文字列バッファを指定文字コードでクリア
==	to     文字列バッファ
==	code   文字コード
==	len    クリアする文字数
==
==	return : EOM_ アドレス                                       TAYA
======================================================================*/
GLOBAL u8* PM_strclear(u8 *to, u8 code, u16 len);

/*======================================================================
==	文字列コピー後、指定文字数に満たない分だけ、指定文字コードでクリア
==	to     コピー先文字列バッファ
==	from   コピー元文字列
==	code   クリア文字コード
==	len    クリアする文字数
==
==	return : EOM_ アドレス                                        TAYA
======================================================================*/
GLOBAL u8* PM_strcpy_clear(u8 *to, const u8 *from, u8 code, u16 len);

/*======================================================================
==	文字列バッファをEOM_コードでクリア
==	to     文字列バッファ
==	len    クリアする文字数
==
==	return : クリア終端のEOM_ アドレス
======================================================================*/
GLOBAL u8* PM_strclearEOM_(u8 *to, u16 len);

#undef GLOBAL
#endif	/*PM_STR_H*/

